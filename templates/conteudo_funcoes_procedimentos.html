{% extends "modelo.html" %}
{% block conteudo %}

<div class="container" xmlns="http://www.w3.org/1999/html">
        <h1>Fun√ß√µes e "Procedimentos" em Python ‚öôÔ∏è</h1>

        </br>

        <p>Fun√ß√µes s√£o blocos de c√≥digo nomeados que realizam uma tarefa espec√≠fica. Elas s√£o um dos pilares da programa√ß√£o estruturada e ajudam a tornar o c√≥digo mais organizado, reutiliz√°vel e f√°cil de manter. Em Python, o termo "procedimento" √© geralmente englobado pelo conceito de fun√ß√£o (uma fun√ß√£o que n√£o retorna um valor explicitamente ou retorna <code>None</code>).</p>

        <hr>

        <h2>1. Definindo e Chamando Fun√ß√µes</h2>
        <p>Usa-se a palavra-chave <code>def</code> para definir uma fun√ß√£o, seguida pelo nome da fun√ß√£o, par√™nteses <code>()</code> e dois pontos <code>:</code>. O corpo da fun√ß√£o √© indentado.</p>

        <h3>Fun√ß√£o que Realiza uma A√ß√£o (similar a um "Procedimento"):</h3>
        <p>Este tipo de fun√ß√£o executa uma s√©rie de instru√ß√µes, mas n√£o retorna um valor explicitamente para ser usado em atribui√ß√µes.</p>
        <pre><code>
# Definindo uma fun√ß√£o que sa√∫da o usu√°rio
def saudar(nome):
    print(f"Ol√°, {nome}! Bem-vindo(a).")

# Chamando a fun√ß√£o
saudar("Alice")
saudar("Roberto")
        </code></pre>
        <p><strong>Sa√≠da Esperada:</strong></p>
        <pre><code>
Ol√°, Alice! Bem-vindo(a).
Ol√°, Roberto! Bem-vindo(a).
        </code></pre>
        <p>Se voc√™ tentar atribuir o resultado de <code>saudar("Alice")</code> a uma vari√°vel e imprimi-la, ver√° <code>None</code>:</p>
        <pre><code>
resultado_saudacao = saudar("Carlos") # A fun√ß√£o saudar imprime, mas n√£o retorna valor
print(f"Resultado da sauda√ß√£o: {resultado_saudacao}")
        </code></pre>
        <p><strong>Sa√≠da Esperada:</strong></p>
        <pre><code>
Ol√°, Carlos! Bem-vindo(a).
Resultado da sauda√ß√£o: None
        </code></pre>


        <h3>Fun√ß√£o que Retorna um Valor:</h3>
        <p>Estas fun√ß√µes realizam c√°lculos ou processamentos e usam a instru√ß√£o <code>return</code> para enviar um valor de volta para quem a chamou.</p>
        <pre><code>
# Definindo uma fun√ß√£o que soma dois n√∫meros
def somar(a, b):
    resultado = a + b
    return resultado

# Chamando a fun√ß√£o e armazenando o resultado
soma = somar(10, 5)
print(f"A soma de 10 e 5 √©: {soma}")

outra_soma = somar(100, -20)
print(f"A soma de 100 e -20 √©: {outra_soma}")
        </code></pre>
        <p><strong>Sa√≠da Esperada:</strong></p>
        <pre><code>
A soma de 10 e 5 √©: 15
A soma de 100 e -20 √©: 80
        </code></pre>

        <hr>

        <h2>2. Par√¢metros e Argumentos</h2>
        <p><strong>Par√¢metros</strong> s√£o as vari√°veis listadas dentro dos par√™nteses na defini√ß√£o da fun√ß√£o. <strong>Argumentos</strong> s√£o os valores reais passados para a fun√ß√£o quando ela √© chamada.</p>

        <h3>Par√¢metros Posicionais:</h3>
        <p>Os argumentos s√£o passados na ordem em que os par√¢metros s√£o definidos.</p>
        <pre><code>
def descrever_pet(tipo_animal, nome_animal):
    print(f"Eu tenho um {tipo_animal}.")
    print(f"Meu {tipo_animal} se chama {nome_animal}.")

descrever_pet("cachorro", "Rex")
# descrever_pet("Rex", "cachorro") # Ordem errada levaria a uma descri√ß√£o incorreta
        </code></pre>

        <h3>Argumentos Nomeados (Keyword Arguments):</h3>
        <p>Voc√™ pode especificar a qual par√¢metro cada argumento corresponde, independentemente da ordem.</p>
        <pre><code>
def descrever_pet(tipo_animal, nome_animal):
    print(f"Eu tenho um {tipo_animal}.")
    print(f"Meu {tipo_animal} se chama {nome_animal}.")

descrever_pet(nome_animal="Lily", tipo_animal="gato")
        </code></pre>

        <h3>Valores Padr√£o para Par√¢metros:</h3>
        <p>Voc√™ pode definir um valor padr√£o para um par√¢metro. Se um argumento para esse par√¢metro n√£o for fornecido na chamada da fun√ß√£o, o valor padr√£o ser√° usado.</p>
        <pre><code>
def potencia(base, expoente=2): # expoente tem valor padr√£o 2
    return base ** expoente

print(f"5 ao quadrado: {potencia(5)}")       # Usa expoente padr√£o 2 -> Sa√≠da: 25
print(f"3 ao cubo: {potencia(3, 3)}")        # Fornece o expoente 3 -> Sa√≠da: 27
print(f"2 elevado a 4: {potencia(base=2, expoente=4)}") # Sa√≠da: 16
        </code></pre>

        <hr>

        <h2>3. A Instru√ß√£o <code>return</code></h2>
        <p>A instru√ß√£o <code>return</code> finaliza a execu√ß√£o da fun√ß√£o e, opcionalmente, retorna um valor. Uma fun√ß√£o pode ter m√∫ltiplas instru√ß√µes <code>return</code> (por exemplo, dentro de condicionais), mas apenas uma ser√° executada.</p>

        <h3>Retornando M√∫ltiplos Valores:</h3>
        <p>Python permite retornar m√∫ltiplos valores de uma fun√ß√£o. Na verdade, a fun√ß√£o retorna uma tupla contendo esses valores, que pode ser desempacotada.</p>
        <pre><code>
def calcular_operacoes(x, y):
    soma = x + y
    diferenca = x - y
    produto = x * y
    return soma, diferenca, produto # Retorna uma tupla (soma, diferenca, produto)

res_soma, res_dif, res_prod = calcular_operacoes(10, 4)
print(f"Soma: {res_soma}")         # Sa√≠da: Soma: 14
print(f"Diferen√ßa: {res_dif}")   # Sa√≠da: Diferen√ßa: 6
print(f"Produto: {res_prod}")     # Sa√≠da: Produto: 40

# Ou receber a tupla inteira
resultados = calcular_operacoes(7, 2)
print(f"Resultados como tupla: {resultados}") # Sa√≠da: Resultados como tupla: (9, 5, 14)
        </code></pre>

        <hr>

        <h2>4. Escopo de Vari√°veis</h2>
        <p>O escopo de uma vari√°vel √© a parte do programa onde ela √© reconhecida.</p>
        <ul>
            <li><strong>Vari√°veis Locais:</strong> Definidas dentro de uma fun√ß√£o. S√≥ podem ser acessadas de dentro dessa fun√ß√£o.</li>
            <li><strong>Vari√°veis Globais:</strong> Definidas fora de todas as fun√ß√µes. Podem ser acessadas (lidas) de qualquer lugar do script, inclusive de dentro das fun√ß√µes.</li>
        </ul>
        <pre><code>
variavel_global = "Sou global"

def minha_funcao():
    variavel_local = "Sou local"
    print(f"Dentro da fun√ß√£o, posso ver a local: '{variavel_local}'")
    print(f"Dentro da fun√ß√£o, posso ver a global: '{variavel_global}'")

minha_funcao()
print(f"Fora da fun√ß√£o, posso ver a global: '{variavel_global}'")
# print(f"Fora da fun√ß√£o, N√ÉO posso ver a local: {variavel_local}") # Isso geraria um NameError
        </code></pre>
        <p>Para modificar uma vari√°vel global dentro de uma fun√ß√£o, voc√™ precisa usar a palavra-chave <code>global</code>. No entanto, seu uso excessivo √© desencorajado, pois pode dificultar o rastreamento de modifica√ß√µes de vari√°veis.</p>
        <pre><code>
contador = 0

def incrementar_contador():
    global contador # Avisa que queremos modificar a vari√°vel global 'contador'
    contador += 1
    print(f"Contador dentro da fun√ß√£o: {contador}")

incrementar_contador()
incrementar_contador()
print(f"Contador fora da fun√ß√£o: {contador}") # Sa√≠da: 2
        </code></pre>

        <hr>

        <h2>5. Docstrings (Strings de Documenta√ß√£o)</h2>
        <p>√â uma boa pr√°tica incluir uma string de documenta√ß√£o (docstring) como a primeira instru√ß√£o em uma fun√ß√£o. Ela descreve o que a fun√ß√£o faz. Docstrings s√£o colocadas entre aspas triplas (<code>"""Docstring aqui"""</code> ou <code>'''Docstring aqui'''</code>).</p>
        <pre><code>
def calcular_media(lista_numeros):
    """
    Calcula e retorna a m√©dia de uma lista de n√∫meros.

    Par√¢metros:
    lista_numeros (list): Uma lista de n√∫meros (int ou float).

    Retorna:
    float: A m√©dia dos n√∫meros na lista. Retorna 0 se a lista estiver vazia.
    """
    if not lista_numeros:
        return 0
    return sum(lista_numeros) / len(lista_numeros)

# Acessando a docstring
print(calcular_media.__doc__)

media = calcular_media([10, 20, 30, 40])
print(f"\nM√©dia calculada: {media}")
        </code></pre>

        <div class="note">
            <h3>Fun√ß√µes Lambda (An√¥nimas)</h3>
            <p>Python tamb√©m suporta fun√ß√µes pequenas e an√¥nimas chamadas fun√ß√µes lambda. Elas s√£o definidas com a palavra-chave <code>lambda</code> e s√£o restritas a uma √∫nica express√£o.</p>
            <p><strong>Sintaxe:</strong> <code>lambda argumentos: expressao</code></p>
            <pre><code>
# Fun√ß√£o lambda que dobra um n√∫mero
dobrar = lambda x: x * 2
print(f"O dobro de 7 √©: {dobrar(7)}") # Sa√≠da: O dobro de 7 √©: 14

# Fun√ß√£o lambda que soma dois n√∫meros
adicionar = lambda a, b: a + b
print(f"A soma de 3 e 4 √©: {adicionar(3, 4)}") # Sa√≠da: A soma de 3 e 4 √©: 7
            </code></pre>
            <p>Fun√ß√µes lambda s√£o frequentemente usadas quando uma fun√ß√£o pequena √© necess√°ria por um curto per√≠odo, como argumento para outra fun√ß√£o (por exemplo, em <code>sorted()</code>, <code>map()</code>, <code>filter()</code>).</p>
        </div>

        <hr>
        <p>Dominar fun√ß√µes √© crucial para escrever c√≥digo Python eficiente e bem estruturado. Elas s√£o a base para criar programas mais complexos e modulares! üòä</p>
    </div>

{% endblock %}